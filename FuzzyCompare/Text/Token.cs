namespace FuzzyCompare.Text
{
    using System;
    using System.Diagnostics;

    /// <summary>
    /// Represents a token generated by the tokenizer.
    /// </summary>
    [DebuggerDisplay("{Category}: {ToString()}")]
    public readonly struct Token : IEquatable<Token>, IEquatable<string>, IEquatable<char>
    {
        private const StringComparison comparison = StringComparison.OrdinalIgnoreCase;

        private readonly ReadOnlyMemory<char> source;
        private readonly Range range;

        /// <summary>
        /// Initializes a new instance of the <see cref="Token"/> struct.
        /// </summary>
        /// <param name="source">The source memory that the token is extracted from.</param>
        /// <param name="range">The range of the memory that the token represents.</param>
        /// <param name="category">The category of the token.</param>
        internal Token(ReadOnlyMemory<char> source, Range range, TokenCategory category)
        {
            this.source = source;
            this.range = range;
            this.Category = category;
        }

        /// <summary>
        /// Gets the span of the token's source memory that it represents.
        /// </summary>
        public ReadOnlySpan<char> Span => this.source[this.range].Span;
        /// <summary>
        /// Gets the category of the token.
        /// </summary>
        public TokenCategory Category { get; }

        /// <summary>
        /// Gets the length of the token.
        /// </summary>
        private int Length => this.range.GetOffsetAndLength(this.source.Length).Length;

        /// <summary>
        /// Implicitly converts a <see cref="Token"/> to a <see cref="ReadOnlySpan{T}"/> of <see cref="char"/>.
        /// </summary>
        /// <param name="token">The token to convert.</param>
        public static implicit operator ReadOnlySpan<char>(Token token) => token.Span;

        /// <summary>
        /// Determines whether two tokens are equal.
        /// </summary>
        /// <param name="a">The first token to compare.</param>
        /// <param name="b">The second token to compare.</param>
        public static bool operator ==(Token a, Token b) => a.Equals(b);

        /// <summary>
        /// Determines whether a token is equal to a string.
        /// </summary>
        /// <param name="a">The token to compare.</param>
        /// <param name="b">The string to compare.</param>
        public static bool operator ==(Token a, string b) => a.Equals(b);

        /// <summary>
        /// Determines whether a token is equal to a character.
        /// </summary>
        /// <param name="a">The token to compare.</param>
        /// <param name="b">The character to compare.</param>
        public static bool operator ==(Token a, char b) => a.Equals(b);

        /// <summary>
        /// Determines whether two tokens are not equal.
        /// </summary>
        /// <param name="a">The first token to compare.</param>
        /// <param name="b">The second token to compare.</param>
        public static bool operator !=(Token a, Token b) => !(a == b);

        /// <summary>
        /// Determines whether a token is not equal to a string
        /// </summary>
        /// <param name="a">The token to compare.</param>
        /// <param name="b">The string to compare.</param>
        public static bool operator !=(Token a, string b) => !(a == b);

        /// <summary>
        /// Determines whether a token is not equal to a character.
        /// </summary>
        /// <param name="a">The token to compare.</param>
        /// <param name="b">The character to compare.</param>
        public static bool operator !=(Token a, char b) => !(a == b);

        /// <summary>
        /// Returns a string representation of the token.
        /// </summary>
        public override string ToString() => this.source[this.range].ToString();

        /// <summary>
        /// Returns the hash code of the token.
        /// </summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(String.GetHashCode(this.source[this.range].Span, comparison), this.Category);
        }

        /// <summary>
        /// Determines whether the token is equal to the specified object.
        /// </summary>
        /// <param name="obj">The object to compare.</param>
        public override bool Equals(object? obj)
        {
            return obj switch
            {
                Token token => Equals(token),
                string str => Equals(str),
                char ch => Equals(ch),
                _ => false,
            };
        }

        /// <summary>
        /// Determines whether the token is equal to another token.
        /// </summary>
        /// <param name="other">The token to compare.</param>
        public bool Equals(Token other)
        {
            if (this.Category != other.Category || this.Length != other.Length)
                return false;

            return EqualsSpan(other.Span);
        }

        /// <summary>
        /// Determines whether the token is equal to a string.
        /// </summary>
        /// <param name="other">The string to compare.</param>
        public bool Equals(string? other)
        {
            if (other is null || this.Length != other.Length)
                return false;

            return EqualsSpan(other);
        }

        /// <summary>
        /// Determines whether the token is equal to a character.
        /// </summary>
        /// <param name="other">The character to compare.</param>
        public bool Equals(char other)
        {
            if (this.Length != 1)
                return false;

            return Char.ToUpperInvariant(this.source[this.range].Span[0]).Equals(Char.ToUpperInvariant(other));
        }

        /// <summary>
        /// Determines whether the span of the token is equal to the specified span.
        /// </summary>
        /// <param name="span">The span to compare.</param>
        private bool EqualsSpan(ReadOnlySpan<char> span)
        {
            return this.Span.Equals(span, comparison);
        }
    }
}